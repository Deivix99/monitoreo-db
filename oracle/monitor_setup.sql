-- 1) Privilegios necesarios para MONITOR (ejecutar como SYSDBA en XEPDB1)
GRANT CREATE TABLE TO MONITOR;
GRANT CREATE PROCEDURE TO MONITOR;
GRANT CREATE VIEW TO MONITOR;
GRANT CREATE SESSION TO MONITOR;
GRANT EXECUTE ON DBMS_DATAPUMP TO MONITOR;   -- para usar datadump desde PL/SQL
GRANT READ, WRITE ON DIRECTORY DATA_PUMP_DIR TO MONITOR; -- si vas a usar DATA_PUMP_DIR
-- (si DATA_PUMP_DIR no existe o quieres otro directorio, crea uno y otorga permisos)

-- 2) Crear la tabla de auditoría de backups (ahora MONITOR ya puede crear tablas)
-- Ejecutar esto COMO MONITOR o como SYS (si prefieres, crea la tabla como SYS y da permisos)
CONNECT monitor/tu_clave@localhost:1521/XEPDB1
CREATE TABLE monitor_backup_log (
  id           NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  backup_type  VARCHAR2(30),           -- 'DATAPUMP_SCHEMA'
  start_time   TIMESTAMP,
  end_time     TIMESTAMP,
  status       VARCHAR2(1000),         -- COMPLETED / FAILED: <error>
  dumpfile     VARCHAR2(260),
  logfile      VARCHAR2(260),
  bytes        NUMBER                  -- tamaño aproximado del .dmp
);

-- 3) Procedimientos auxiliares (puedes crearlos como MONITOR ahora)
SET DEFINE OFF;

CREATE OR REPLACE PROCEDURE sp_gather_schema_stats(p_owner IN VARCHAR2) IS
BEGIN
  DBMS_STATS.GATHER_SCHEMA_STATS(
    ownname          => p_owner,
    options          => 'GATHER',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    method_opt       => 'FOR ALL COLUMNS SIZE AUTO',
    cascade          => TRUE
  );
END;
/

CREATE OR REPLACE PROCEDURE sp_recompile_invalids(p_owner IN VARCHAR2)
AUTHID DEFINER
AS
BEGIN
  DBMS_UTILITY.COMPILE_SCHEMA(
    schema      => UPPER(p_owner),
    compile_all => FALSE   -- solo inválidos
  );
END;
/
-- SHOW ERRORS si hace falta:
SHOW ERRORS;

-- 4) Procedimiento de backup (ajustado). Nota: MONITOR necesita permiso para ejecutar DBMS_DATAPUMP
CREATE OR REPLACE PROCEDURE sp_backup_schema(
  p_owner   VARCHAR2 DEFAULT USER,
  p_dir     VARCHAR2 DEFAULT 'DATA_PUMP_DIR'
) AS
  h           NUMBER;          -- handle de Data Pump
  job_state   VARCHAR2(30);
  sts         KU$_STATUS;
  v_dump      VARCHAR2(128);
  v_log       VARCHAR2(128);
  v_id        NUMBER;
  v_start     TIMESTAMP := SYSTIMESTAMP;
  v_exists    BOOLEAN;
  v_len       NUMBER;
BEGIN
  v_dump := LOWER(p_owner)||'_'||TO_CHAR(SYSTIMESTAMP,'YYYYMMDD_HH24MISS')||'.dmp';
  v_log  := LOWER(p_owner)||'_'||TO_CHAR(SYSTIMESTAMP,'YYYYMMDD_HH24MISS')||'.log';

  INSERT INTO monitor_backup_log(backup_type, start_time, status, dumpfile, logfile)
  VALUES ('DATAPUMP_SCHEMA', v_start, 'RUNNING', v_dump, v_log)
  RETURNING id INTO v_id;
  COMMIT;

  h := DBMS_DATAPUMP.OPEN(operation => 'EXPORT', job_mode => 'SCHEMA', version => 'LATEST');

  DBMS_DATAPUMP.ADD_FILE(h, v_dump, p_dir, NULL, DBMS_DATAPUMP.KU$_FILE_TYPE_DUMP_FILE);
  DBMS_DATAPUMP.ADD_FILE(h, v_log,  p_dir, NULL, DBMS_DATAPUMP.KU$_FILE_TYPE_LOG_FILE);

  DBMS_DATAPUMP.METADATA_FILTER(h, 'SCHEMA_EXPR', 'IN ('''||UPPER(p_owner)||''')');

  DBMS_DATAPUMP.START_JOB(h);
  DBMS_DATAPUMP.WAIT_FOR_JOB(h, job_state, sts);
  DBMS_DATAPUMP.DETACH(h);

  -- Intentar obtener tamaño del .dmp (si el DB tiene acceso UTL_FILE al DIR)
  BEGIN
    UTL_FILE.FGETATTR(p_dir, v_dump, v_exists, v_len, /*v_bs*/  );
  EXCEPTION WHEN OTHERS THEN
    v_exists := FALSE; v_len := NULL;
  END;

  UPDATE monitor_backup_log
     SET end_time = SYSTIMESTAMP,
         status   = NVL(job_state,'COMPLETED'),
         bytes    = v_len
   WHERE id = v_id;
  COMMIT;

EXCEPTION
  WHEN OTHERS THEN
    UPDATE monitor_backup_log
       SET end_time = SYSTIMESTAMP,
           status   = 'FAILED: '||SUBSTR(SQLERRM,1,900)
     WHERE id = v_id;
    COMMIT;
    RAISE;
END;
/

-- Si la compilación falla, haz:
SHOW ERRORS;

-- 5) Vistas corregidas y robustas

-- A) Métricas cortas (ya la tenías, la dejamos igual)
CREATE OR REPLACE VIEW vw_sys_metrics AS
SELECT
  metric_name,
  value,
  begin_time,
  end_time,
  intsize_csec
FROM v$sysmetric_history
WHERE group_id = 2
-- Nota: quitar ORDER BY en la vista (el orden lo controlas en el SELECT que haga el cliente)
;

-- B) Resumen host / memoria / CPU (corregido: agregación y GROUP BY)
CREATE OR REPLACE VIEW vw_host_mem_cpu AS
SELECT
  os.num_cpu_cores,
  os.num_cpus_logical,
  os.host_mem_bytes,
  SUM(CASE WHEN mem.component LIKE 'SGA%' THEN mem.bytes ELSE 0 END) AS sga_bytes,
  SUM(CASE WHEN mem.component LIKE 'PGA%' THEN mem.bytes ELSE 0 END) AS pga_bytes
FROM
  (SELECT
     MAX(CASE WHEN stat_name = 'NUM_CPU_CORES' THEN value END) AS num_cpu_cores,
     MAX(CASE WHEN stat_name = 'NUM_CPUS' THEN value END) AS num_cpus_logical,
     MAX(CASE WHEN stat_name = 'PHYSICAL_MEMORY_BYTES' THEN value END) AS host_mem_bytes
   FROM v$osstat) os,
  (SELECT component, current_size AS bytes
   FROM v$memory_dynamic_components
   WHERE current_size > 0) mem
GROUP BY os.num_cpu_cores, os.num_cpus_logical, os.host_mem_bytes
;

-- SGA summary (tuya, estaba bien)
CREATE OR REPLACE VIEW vw_sga_summary AS
SELECT
  REPLACE(component, ' ', '_') AS component,
  ROUND(current_size / 1024 / 1024, 2) AS current_mb
FROM v$sga_dynamic_components
WHERE current_size > 0
;

-- Tablespace usage (usar ON en lugar de USING)
CREATE OR REPLACE VIEW vw_tablespace_usage AS
WITH t AS (
  SELECT tablespace_name, SUM(bytes) AS total_bytes
  FROM dba_data_files
  GROUP BY tablespace_name
),
f AS (
  SELECT tablespace_name, SUM(bytes) AS free_bytes
  FROM dba_free_space
  GROUP BY tablespace_name
)
SELECT
  t.tablespace_name,
  t.total_bytes,
  NVL(f.free_bytes, 0) AS free_bytes,
  (t.total_bytes - NVL(f.free_bytes, 0)) AS used_bytes,
  ROUND(((t.total_bytes - NVL(f.free_bytes, 0)) / NULLIF(t.total_bytes, 0)) * 100, 2) AS used_pct
FROM t
LEFT JOIN f ON t.tablespace_name = f.tablespace_name
;

-- Last backup: sumar tamaño desde v$backup_piece (no asumir columna bytes en v$backup_set)
CREATE OR REPLACE VIEW vw_last_backup AS
SELECT
  bs.set_stamp,
  bs.set_count,
  bs.incremental_level,
  CASE WHEN bs.incremental_level IS NULL THEN 'FULL' ELSE 'INCR' || bs.incremental_level END AS backup_type,
  bs.start_time,
  bs.completion_time,
  NVL(SUM(bp.bytes), 0) AS bytes
FROM v$backup_set bs
LEFT JOIN v$backup_piece bp
  ON bp.set_stamp = bs.set_stamp AND bp.set_count = bs.set_count
WHERE bs.completion_time IS NOT NULL
GROUP BY bs.set_stamp, bs.set_count, bs.incremental_level, bs.start_time, bs.completion_time
;

-- Top SQL por CPU/elapsed (usar v$sql o v$sqlarea según disponibilidad)
CREATE OR REPLACE VIEW vw_top_sql_cpu AS
SELECT
  sql_id,
  parsing_schema_name AS owner,
  executions,
  ROUND(cpu_time/1e6,2) AS cpu_sec,
  ROUND(elapsed_time/1e6,2) AS elapsed_sec,
  SUBSTR(sql_text,1,1000) AS sql_text
FROM v$sql
WHERE executions > 0
ORDER BY cpu_time DESC
FETCH FIRST 50 ROWS ONLY
;

CREATE OR REPLACE VIEW vw_top_sql_elapsed AS
SELECT
  sql_id,
  parsing_schema_name AS owner,
  executions,
  ROUND(cpu_time/1e6,2) AS cpu_sec,
  ROUND(elapsed_time/1e6,2) AS elapsed_sec,
  SUBSTR(sql_text,1,1000) AS sql_text
FROM v$sql
WHERE executions > 0
ORDER BY elapsed_time DESC
FETCH FIRST 50 ROWS ONLY
;

-- Sesiones activas y detalle de sesiones (vistas ya corregidas)
CREATE OR REPLACE VIEW vw_active_sessions AS
SELECT
  s.inst_id,
  s.sid,
  s.serial#,
  s.username,
  s.status,
  s.type,
  s.machine,
  s.program,
  s.module,
  s.sql_id,
  s.event,
  s.state,
  s.wait_class,
  s.seconds_in_wait,
  s.logon_time
FROM gv$session s
WHERE s.status = 'ACTIVE'
  AND s.type = 'USER'
;

CREATE OR REPLACE VIEW vw_sessions_detail AS
SELECT
  s.inst_id,
  s.sid,
  s.serial#,
  s.username,
  s.osuser,
  s.machine,
  s.program,
  s.module,
  s.status,
  s.type,
  s.event,
  s.wait_class,
  s.state,
  s.seconds_in_wait,
  s.sql_id,
  SUBSTR(q.sql_text, 1, 1000) AS sql_text,
  s.logon_time,
  s.blocking_session,
  s.blocking_session_status
FROM gv$session s
LEFT JOIN gv$sql q
  ON q.inst_id = s.inst_id AND q.sql_id = s.sql_id
WHERE s.type = 'USER'
ORDER BY s.status DESC, s.seconds_in_wait DESC
;

-- Objetos inválidos
CREATE OR REPLACE VIEW vw_invalid_objects AS
SELECT owner, object_name, object_type, status, last_ddl_time
FROM dba_objects
WHERE status = 'INVALID'
ORDER BY owner, object_type, object_name
;
