-- ==========================================================================
-- UNIVERSIDAD NACIONAL – EIF402 Administración de Bases de Datos
-- PROYECTO: Monitoreo básico Oracle
-- AUTOR: Alejandro Álvarez
-- AMBIENTE: Oracle XE 21c - PDB XEPDB1
-- EJECUTAR COMO SYSDBA
-- ==========================================================================

CONNECT / AS SYSDBA;
ALTER SESSION SET CONTAINER = XEPDB1;

--PROMPT === 1) Limpiar usuario anterior (si existe) ===
BEGIN
  EXECUTE IMMEDIATE 'DROP USER MONITOR CASCADE';
EXCEPTION WHEN OTHERS THEN
  IF SQLCODE != -1918 THEN RAISE; END IF;
END;
/

--PROMPT === 2) Crear usuario MONITOR local en la PDB ===
CREATE USER MONITOR IDENTIFIED BY "root"
  DEFAULT TABLESPACE USERS
  TEMPORARY TABLESPACE TEMP
  QUOTA UNLIMITED ON USERS;

--PROMPT === 3) Otorgar privilegios necesarios ===
GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW, CREATE PROCEDURE TO MONITOR;
GRANT SELECT_CATALOG_ROLE, SELECT ANY DICTIONARY TO MONITOR;
GRANT EXECUTE ON DBMS_DATAPUMP TO MONITOR;
GRANT READ, WRITE ON DIRECTORY DATA_PUMP_DIR TO MONITOR;
GRANT UNLIMITED TABLESPACE TO MONITOR;
GRANT RESOURCE TO MONITOR;

-- Vistas dinámicas usadas por el dashboard
GRANT SELECT ON SYS.V_$SYSMETRIC            TO MONITOR;
GRANT SELECT ON SYS.V_$SYSMETRIC_HISTORY    TO MONITOR;
GRANT SELECT ON SYS.V_$OSSTAT               TO MONITOR;
GRANT SELECT ON SYS.V_$MEMORY_DYNAMIC_COMPONENTS TO MONITOR;
GRANT SELECT ON SYS.V_$SGA_DYNAMIC_COMPONENTS TO MONITOR;
GRANT SELECT ON SYS.V_$SQL                  TO MONITOR;
GRANT SELECT ON SYS.V_$SQLAREA              TO MONITOR;
GRANT SELECT ON SYS.V_$SQLSTATS             TO MONITOR;
GRANT SELECT ON SYS.GV_$SESSION             TO MONITOR;
GRANT SELECT ON SYS.GV_$SQL                 TO MONITOR;
GRANT SELECT ON SYS.DBA_DATA_FILES          TO MONITOR;
GRANT SELECT ON SYS.DBA_FREE_SPACE          TO MONITOR;
GRANT SELECT ON SYS.DBA_TABLESPACES         TO MONITOR;
GRANT SELECT ON SYS.DBA_OBJECTS             TO MONITOR;

--PROMPT === 4) Conectarse como MONITOR ===
CONNECT monitor/root@localhost:1521/XEPDB1;
SHOW USER;

-- ======================================================================
-- MÓDULO DE AUDITORÍA DE BACKUPS
-- ======================================================================

--PROMPT === 5) Crear tabla de auditoría de backups ===
CREATE TABLE monitor_backup_log (
  id           NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  backup_type  VARCHAR2(30),
  start_time   TIMESTAMP,
  end_time     TIMESTAMP,
  status       VARCHAR2(1000),
  dumpfile     VARCHAR2(260),
  logfile      VARCHAR2(260),
  bytes        NUMBER
);

--PROMPT === 6) Crear procedimiento de respaldo automático ===
CREATE OR REPLACE PROCEDURE sp_backup_schema(
  p_owner   VARCHAR2 DEFAULT USER,
  p_dir     VARCHAR2 DEFAULT 'DATA_PUMP_DIR'
) AS
  h           NUMBER;
  job_state   VARCHAR2(30);
  sts         KU$_STATUS;
  v_dump      VARCHAR2(128);
  v_log       VARCHAR2(128);
  v_id        NUMBER;
  v_start     TIMESTAMP := SYSTIMESTAMP;
  v_exists    BOOLEAN;
  v_len       NUMBER;
BEGIN
  v_dump := LOWER(p_owner)||'_'||TO_CHAR(SYSTIMESTAMP,'YYYYMMDD_HH24MISS')||'.dmp';
  v_log  := LOWER(p_owner)||'_'||TO_CHAR(SYSTIMESTAMP,'YYYYMMDD_HH24MISS')||'.log';

  INSERT INTO monitor_backup_log(backup_type, start_time, status, dumpfile, logfile)
  VALUES ('DATAPUMP_SCHEMA', v_start, 'RUNNING', v_dump, v_log)
  RETURNING id INTO v_id;
  COMMIT;

  h := DBMS_DATAPUMP.OPEN(operation => 'EXPORT', job_mode => 'SCHEMA', version => 'LATEST');
  DBMS_DATAPUMP.ADD_FILE(h, v_dump, p_dir, NULL, DBMS_DATAPUMP.KU$_FILE_TYPE_DUMP_FILE);
  DBMS_DATAPUMP.ADD_FILE(h, v_log,  p_dir, NULL, DBMS_DATAPUMP.KU$_FILE_TYPE_LOG_FILE);
  DBMS_DATAPUMP.METADATA_FILTER(h, 'SCHEMA_EXPR', 'IN ('''||UPPER(p_owner)||''')');
  DBMS_DATAPUMP.START_JOB(h);
  DBMS_DATAPUMP.WAIT_FOR_JOB(h, job_state, sts);
  DBMS_DATAPUMP.DETACH(h);

  BEGIN
    UTL_FILE.FGETATTR(p_dir, v_dump, v_exists, v_len);
  EXCEPTION WHEN OTHERS THEN
    v_exists := FALSE; v_len := NULL;
  END;

  UPDATE monitor_backup_log
     SET end_time = SYSTIMESTAMP,
         status   = NVL(job_state,'COMPLETED'),
         bytes    = v_len
   WHERE id = v_id;
  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    UPDATE monitor_backup_log
       SET end_time = SYSTIMESTAMP,
           status   = 'FAILED: '||SUBSTR(SQLERRM,1,900)
     WHERE id = v_id;
    COMMIT;
    RAISE;
END;
/

--PROMPT === 7) Crear vista del último backup ===
CREATE OR REPLACE VIEW vw_last_backup AS
SELECT
  TO_CHAR(end_time, 'YYYY-MM-DD"T"HH24:MI:SS') AS last_backup_end,
  status         AS last_status,
  backup_type,
  dumpfile,
  logfile,
  bytes
FROM monitor_backup_log
WHERE end_time IS NOT NULL
ORDER BY end_time DESC;
/

--PROMPT === 8) Insertar registro de prueba ===
INSERT INTO monitor_backup_log
(backup_type, start_time, end_time, status, dumpfile, logfile, bytes)
VALUES ('DATAPUMP_SCHEMA', SYSTIMESTAMP-1/24, SYSTIMESTAMP, 'COMPLETED',
        'monitor_20251106_120000.dmp', 'monitor_20251106_120000.log', 10485760);
COMMIT;

-- ======================================================================
-- MÓDULO DE MÉTRICAS, SESSIONS, SQL Y TABLESPACES
-- ======================================================================

--PROMPT === 9) Crear vistas del dashboard ===

-- Métricas del sistema
CREATE OR REPLACE VIEW vw_sys_metrics AS
SELECT metric_name, value, begin_time, end_time, intsize_csec
FROM v$sysmetric_history
WHERE group_id = 2;

-- Uso de tablespaces
CREATE OR REPLACE VIEW vw_tablespace_usage AS
WITH t AS (
  SELECT tablespace_name, SUM(bytes) AS total_bytes FROM dba_data_files GROUP BY tablespace_name
),
f AS (
  SELECT tablespace_name, SUM(bytes) AS free_bytes FROM dba_free_space GROUP BY tablespace_name
)
SELECT
  t.tablespace_name,
  t.total_bytes,
  NVL(f.free_bytes, 0) AS free_bytes,
  (t.total_bytes - NVL(f.free_bytes, 0)) AS used_bytes,
  ROUND(((t.total_bytes - NVL(f.free_bytes, 0))/NULLIF(t.total_bytes,0))*100,2) AS used_pct
FROM t LEFT JOIN f ON t.tablespace_name=f.tablespace_name;

-- Top SQL (por CPU y por tiempo)
CREATE OR REPLACE VIEW vw_top_sql_cpu AS
SELECT
  sql_id,
  parsing_schema_name AS owner,
  executions,
  ROUND(cpu_time/1e6,2) AS cpu_sec,
  ROUND(elapsed_time/1e6,2) AS elapsed_sec,
  SUBSTR(sql_text,1,1000) AS sql_text
FROM v$sql
WHERE executions > 0
ORDER BY cpu_time DESC
FETCH FIRST 50 ROWS ONLY;

CREATE OR REPLACE VIEW vw_top_sql_elapsed AS
SELECT
  sql_id,
  parsing_schema_name AS owner,
  executions,
  ROUND(cpu_time/1e6,2) AS cpu_sec,
  ROUND(elapsed_time/1e6,2) AS elapsed_sec,
  SUBSTR(sql_text,1,1000) AS sql_text
FROM v$sql
WHERE executions > 0
ORDER BY elapsed_time DESC
FETCH FIRST 50 ROWS ONLY;

-- Sesiones activas y detalle
CREATE OR REPLACE VIEW vw_active_sessions AS
SELECT
  s.inst_id, s.sid, s.serial#, s.username, s.status, s.type, s.machine,
  s.program, s.module, s.sql_id, s.event, s.state, s.wait_class,
  s.seconds_in_wait, s.logon_time
FROM gv$session s
WHERE s.status='ACTIVE' AND s.type='USER';

CREATE OR REPLACE VIEW vw_sessions_detail AS
SELECT
  s.inst_id, s.sid, s.serial#, s.username, s.osuser, s.machine, s.program,
  s.module, s.status, s.type, s.event, s.wait_class, s.state,
  s.seconds_in_wait, s.sql_id, SUBSTR(q.sql_text,1,1000) AS sql_text,
  s.logon_time, s.blocking_session, s.blocking_session_status
FROM gv$session s
LEFT JOIN gv$sql q ON q.inst_id=s.inst_id AND q.sql_id=s.sql_id
WHERE s.type='USER'
ORDER BY s.status DESC, s.seconds_in_wait DESC;

-- Objetos inválidos
CREATE OR REPLACE VIEW vw_invalid_objects AS
SELECT owner, object_name, object_type, status, last_ddl_time
FROM dba_objects
WHERE status='INVALID'
ORDER BY owner, object_type, object_name;

--PROMPT === 10) Verificar todo ===
SELECT 'VW_LAST_BACKUP' AS vista, COUNT(*) AS filas FROM vw_last_backup UNION ALL
SELECT 'VW_TABLESPACE_USAGE', COUNT(*) FROM vw_tablespace_usage UNION ALL
SELECT 'VW_ACTIVE_SESSIONS', COUNT(*) FROM vw_active_sessions UNION ALL
SELECT 'VW_INVALID_OBJECTS', COUNT(*) FROM vw_invalid_objects;
/
